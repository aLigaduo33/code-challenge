# Concurrent Programing

## 并发编程问题的源头
 - 可见性 缓存导致的可见性问题
 - 有序性 编译优化的有序性问题
 - 原子性 线程切换带来的原子性问题
 
## java如何解决并发编程问题
 > volatile，synchronized，final 解决缓存可见性问题,六项 Happens-Before（先于发生）规则：
 
 - 1,程序的顺序性
 在一个线程中，按照程序顺序，前面的操作能背后续操作可见；
 
 - 2,volatile 变量规则: 
 volatile修饰的变量的写操作，之前发生于此变量的后续读操作；
 
 - 3,传递性: 
 a -> b, b -> c; a -> c .
 
 - 4,管程中的规则: 
 对一个锁的解锁操作 -> 对于后续对这个锁的加锁；
 
 - 5,线程start()规则: 
 主线程先于子线程前启动的操作对子线程启动后可见；
 
 - 6,线程的join()规则: 
   主线程 join 出来的 子线程操作共享变量时，能被主线程可见；
   
 ## 互斥锁
 
 ### java synchronized
  > synchronized 为java提供的一种锁的实现，可以修饰方法和代码块；
  - 修饰静态方法时，锁定的是当前Class对象；
  - 修饰非静态方法时，锁定的时当前实例对象；
  
 注意加锁的对象，受保护资源和锁之间合理的关联关系应该是 N:1 的关系，避免造成用多把锁来保护一个资源；
 
 